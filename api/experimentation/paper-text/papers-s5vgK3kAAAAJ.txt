Microservices architecture enables devops: Migration to a cloud-native architecture
This article reports on experiences and lessons learned during incremental migration and architectural refactoring of a commercial mobile back end as a service to microservices architecture. It explains how the researchers adopted DevOps and how this facilitated a smooth migration.

Migrating to cloud-native architectures using microservices: an experience report
Microservices migration patterns
Microservices architectures are becoming the defacto standard for building continuously deployed systems. At the same time, there is a substantial growth in the demand for migrating on‐premise legacy applications to the cloud. In this context, organizations tend to migrate their traditional architectures into cloud‐native architectures using microservices. This article reports a set of migration and rearchitecting design patterns that we have empirically identified and collected from industrial‐scale software migration projects. These migration patterns can help information technology organizations plan their migration projects toward microservices more efficiently and effectively. In addition, the proposed patterns facilitate the definition of migration plans by pattern composition. Qualitative empirical research is used to evaluate the validity of the proposed patterns. Our findings suggest that the proposed patterns are evident in other architectural refactoring and migration projects and strong candidates for effective patterns in system migrations.

A fast vision system for middle size robots in robocup
Predicting the objective and priority of issue reports in software repositories
Topic recommendation for software repositories using multi-label classification algorithms
Cross-project code clones in GitHub
Supporting framework use via automatically extracted concept-implementation templates
Two studies of framework-usage templates extracted from dynamic traces
Object-oriented frameworks are widely used to develop new applications. They provide reusable concepts that are instantiated in application code through potentially complex implementation steps such as subclassing, implementing interfaces, and calling framework operations. Unfortunately, many modern frameworks are difficult to use because of their large and complex APIs and frequently incomplete user documentation. To cope with these problems, developers often use existing framework applications as a guide. However, locating concept implementations in those sample applications is typically challenging due to code tangling and scattering. To address this challenge, we introduce the notion of concept-implementation templates, which summarize the necessary concept-implementation steps and identify them in the sample application code, and a technique, named FUDA, to automatically extract such templates from dynamic traces of sample applications. This paper further presents the results of two experiments conducted to evaluate the quality and usefulness of FUDA templates. The experimental evaluation of FUDA with 14 concepts in five widely used frameworks suggests that the technique is effective in producing templates with relatively few false positives and false negatives for realistic concepts by using two sample applications. Moreover, we observed in a user study with 28 programmers that the use of templates reduced the concept-implementation time compared to when documentation was used.

Crowdsummarizer: Automated generation of code summaries for java programs through crowdsourcing
To perform software maintenance, developers must have a relatively good understanding of the program's source code, which is often written by other developers. Code summaries, which describe a program's entities (for example, its methods), help developers better comprehend code more quickly. However, generating code summaries can be challenging. To mitigate this problem, CrowdSummarizer exploits crowdsourcing, gamification, and natural-language processing to automatically generate high-level summaries of Java program methods. Researchers have implemented it as an Eclipse plug-in together with a Web-based code summarization game that can be played by the crowd. Two empirical studies determined that CrowdSummarizer generates quality results. This article is part of a special issue on Crowdsourcing for Software Engineering.

Visualizing and exploring profiles with calling context ring charts
Calling context profiling is an important technique for analyzing the performance of object-oriented software with complex inter-procedural control flow. The Calling Context Tree (CCT) is a common data structure that stores dynamic metrics, such as CPU time, separately for each calling context. As CCTs may comprise millions of nodes, there is a need for a condensed visualization that eases the localization of performance bottlenecks. In this article, we discuss Calling Context Ring Charts (CCRCs), a compact visualization for CCTs, where callee methods are represented in ring segments surrounding the caller's ring segment. In order to reveal hot methods, their callers, and callees, the ring segments can be sized according to a chosen dynamic metric. We describe two case studies where CCRCs help us to detect and fix performance problems in applications. A performance evaluation also confirms that our implementation can efficiently handle large CCTs. Copyright © 2010 John Wiley & Sons, Ltd.

Towards an automated deployment planner for composition of web services as software components
Deploying component–based applications: Tools and techniques
Reliable deployment of component-based applications into distributed environments
Software deployment process is a sequence of related activities for installing an already developed application into its target environment, and bringing it into an executing state. For complex component-based applications that should be deployed into a large distributed environment, several deployment configurations are typically possible. These deployment configurations can have significant impacts on the application's quality of service properties such as reliability. In distributed systems, the reliability of the application is highly dependent on the reliability of its network, and network failures can have adverse effects on the application's reliability. Thus, one possible way to increase the reliability of a distributed component-based application is to deploy it so that the communications among its components are done as local as possible. In this paper, a graph-based deployment planning approach is proposed for this purpose

Robocup-2001: The fifth robotic soccer world championships
RoboCup-2001 was the Fifth International RoboCup Competition and Conference. It was held for the first time in the United States, following RoboCup-2000 in Melbourne, Australia; RoboCup-99 in Stockholm; RoboCup-98 in Paris; and RoboCup-97 in Osaka. This article discusses in detail each one of the events at RoboCup-2001, focusing on the competition leagues.

A Graph-based Approach for Deploying Component-based Applications into Channel-based Distributed Environments.
With significant advances in software development technologies, it is now possible to have complex software applications, which include a large number of heterogeneous software components distributed over a large network of computers with different computational capabilities. To run such applications, their components must be instantiated on proper hardware resources in their target environments so that user requirements and constraints are also met. This process is called software deployment. However, this process is often challenging for large, distributed, component-based applications with many constraints and requirements. This article presents a graph-based deployment approach that does the deployment with respect to the communication resources required by application components and communication resources available on the hosts in the target environment. In our approach, component-based applications and distributed environments are modeled with the help of graphs. Deployment of an application is then defined as the mapping of the application graph to the target environment graph. This article further discusses how this mapping could be done to minimize the cost and to maximize the reliability of deployments.

Automated recovery of issue-commit links leveraging both textual and non-textual data
An issue report documents the discussions around required changes in issue-tracking systems, while a commit contains the change itself in the version control systems. Recovering links between issues and commits can facilitate many software evolution tasks such as bug localization, defect prediction, software quality measurement, and software documentation. A previous study on over half a million issues from GitHub reports only about 42.2% of issues are manually linked by developers to their pertinent commits. Automating the linking of commit-issue pairs can contribute to the improvement of the said tasks. By far, current state-of-the-art approaches for automated commit-issue linking suffer from low precision, leading to unreliable results, sometimes to the point that imposes human supervision on the predicted links. The low performance gets even more severe when there is a lack of textual information in either commits or issues. Current approaches are also proven computationally expensive. We propose Hybrid-Linker, an enhanced approach that overcomes such limitations by exploiting two information channels; (1) a non-textual-based component that operates on non-textual, automatically recorded information of the commit-issue pairs to predict a link, and (2) a textual-based one which does the same using textual information of the commit-issue pairs. Then, combining the results from the two classifiers, Hybrid-Linker makes the final prediction. Thus, every time one component falls short in predicting a link, the other component fills the gap and improves the results. We evaluate Hybrid-Linker against competing approaches, namely FRLink and DeepLink on a dataset of 12 projects. Hybrid-Linker achieves 90.1%, 87.8%, and 88.9% based on recall, precision, and F-measure, respectively. It also outperforms FRLink and DeepLink by 31.3%, and 41.3%, regarding the F-measure. Moreover, the proposed approach exhibits extensive improvements in terms of performance as well. Finally, our source code and data are publicly available.

ExceptionTracer: A solution recommender for exceptions in an integrated development environment
Exceptions are an indispensable part of the software development process. However, developers usually rely on imprecise results from a web search to resolve exceptions. More specifically, they should personally take into account the context of an exception, then, choose and adapt a relevant solution to solve the problem. In this paper, we present Exception Tracer, an Eclipse plug in that helps developers to resolve exceptions with respect to the stack trace in Java programs. In particular, Exception Tracer automatically provides candidate solutions to an exception by mining software systems in the Source Forge, as well as listing relevant discussions about the problem from the Stack Overflow.

Coaching a soccer simulation team in RoboCup environment
Generating summaries for methods of event-driven programs: An Android case study
DONE