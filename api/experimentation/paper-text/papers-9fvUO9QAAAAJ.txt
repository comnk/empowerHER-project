Abstraction, refinement and proof for probabilistic systems
Probabilistic predicate transformers
Probabilistic predicates generalize standard predicates over a state space; with probabilistic predicate transformers one thus reasons about imperative programs in terms of probabilistic pre- and postconditions. Probabilistic healthiness conditions generalize the standard ones, characterizing “real” probabilistic programs, and are based on a connection with an underlying relational model for probabilistic execution; in both contexts demonic nondeterminism coexists with probabilistic choice. With the healthiness conditions, the associated weakest-precondition calculus seems suitable for exploring the rigorous derivation of small probabilistic programs.

Probabilistic models for the guarded command language
Refinement-oriented probability for CSP
Generalised differential privacy for text document processing
Probabilistic guarded commands mechanized in HOL
Linear-invariant generation for probabilistic programs: Automated support for proof-based methods
Additive and multiplicative notions of leakage, and their capacities
Protecting sensitive information from improper disclosure is a fundamental security goal. It is complicated, and difficult to achieve, often because of unavoidable or even unpredictable operating conditions that can lead to breaches in planned security defences. An attractive approach is to frame the goal as a quantitative problem, and then to design methods that measure system vulnerabilities in terms of the amount of information they leak. A consequence is that the precise operating conditions, and assumptions about prior knowledge, can play a crucial role in assessing the severity of any measured vunerability. We develop this theme by concentrating on vulnerability measures that are robust in the sense of allowing general leakage bounds to be placed on a program, bounds that apply whatever its operating conditions and whatever the prior knowledge might be. In particular we propose a theory of channel capacity, generalising the Shannon capacity of information theory, that can apply both to additive- and to multiplicative forms of a recently-proposed measure known as g-leakage. Further, we explore the computational aspects of calculating these (new) capacities: one of these scenarios can be solved efficiently by expressing it as a Kantorovich distance, but another turns out to be NP-complete. We also find capacity bounds for arbitrary correlations with data not directly accessed by the channel, as in the scenario of Dalenius's Desideratum.

A new proof rule for almost-sure termination
We present a new proof rule for proving almost-sure termination of probabilistic programs, including those that contain demonic non-determinism. An important question for a probabilistic program is whether the probability mass of all its diverging runs is zero, that is that it terminates "almost surely". Proving that can be hard, and this paper presents a new method for doing so. It applies directly to the program's source code, even if the program contains demonic choice. Like others, we use variant functions (a.k.a. "super-martingales") that are real-valued and decrease randomly on each loop iteration; but our key innovation is that the amount as well as the probability of the decrease are parametric. We prove the soundness of the new rule, indicate where its applicability goes beyond existing rules, and explain its connection to classical results on denumerable (non-demonic) Markov chains.

A process algebra for wireless mesh networks
Compositional closure for Bayes risk in probabilistic noninterference
pGCL: Formal reasoning for random algorithms
Dijkstra's guarded-command language GCL contains explicit`demonic' nondeterminism, representing abstraction from (or ignorance of) which of two program fragments will be executed. We introduce probabilistic nondeter-minism to the language, calling the result pGCL. Important is that both forms of nondeterminism are present | both demonic and probabilistic: unlike earlier approaches, we do not deal only with one or the other. The programming logic of`weakest preconditions' for GCL becomes a logic of`greatest pre-expectations' for pGCL: we embed predicates (Boolean-valued expressions over state variables) into arithmetic by writing P ], an expression that is 1 when P holds and 0 when it does not. Thus in a trivial sense P ] is the probability that P is true, and such embedded predicates are the basis for the more elaborate arithmetic expressions that we call \expectations". pGCL is suitable for describing random algorithms, at least over discrete distributions. In our presentation of it and its logic we give two examples: an erratic`sequence accumulator', that fails with some probability to move along the sequence; and Rabin's `choice-coordination' algorithm. The rst illustrates probabilistic invariants; the second illustrates probabilistic variants.

Operational versus weakest pre-expectation semantics for the probabilistic guarded command language
Automated analysis of AODV using UPPAAL
Abstract channels and their robust information-leakage ordering
Partial correctness for probabilistic demonic programs
Enumerating finite groups
The Science of Quantitative Information Flow
Games, Probability, and the Quantitative μ-Calculus qMμ
Results on the quantitative μ-calculus qMμ
The μ-calculus is a powerful tool for specifying and verifying transition systems, including those with both demonic (universal) and angelic (existential) choice; its quantitative generalization qMμ extends to include probabilistic choice.We make two major contributions to the theory of such systems. The first is to show that for a finite-state system, the logical interpretation of qMμ, via fixed points in a domain of real-valued functions into [0, 1], is equivalent to an operational interpretation given as a turn-based gambling game between two players.The second contribution is to show that each player in the gambling game has an optimal memoryless strategy---that is, a strategy which is independent of the game's history, and with which a player can achieve his optimal expected reward however his opponent chooses to play. Moreover, since qMμ is expressive enough to encode stochastic parity games, our result implies the existence of memoryless strategies in that framework, as well.As an additional feature, we include an extensive case study demonstrating the aforementioned duality between games and logic. Among other things, it shows that the use of algorithmic verification techniques is mathematically justified in the practical computation of probabilistic system properties.

DONE