IDMoB: IoT data marketplace on blockchain
Today, Internet of Things (IoT) devices are the powerhouse of data generation with their ever-increasing numbers and widespread penetration. Similarly, artificial intelligence (AI) and machine learning (ML) solutions are getting integrated to all kinds of services, making products significantly more "smarter". The centerpiece of these technologies is "data". IoT device vendors should be able keep up with the increased throughput and come up with new business models. On the other hand, AI/ML solutions will produce better results if training data is diverse and plentiful. In this paper, we propose a blockchain-based, decentralized and trustless data marketplace where IoT device vendors and AI/ML solution providers may interact and collaborate. By facilitating a transparent data exchange platform, access to consented data will be democratized and the variety of services targeting end-users will increase. Proposed data marketplace is implemented as a smart contract on Ethereum blockchain and Swarm is used as the distributed storage platform.

Designing a Blockchain-based IoT with Ethereum, swarm, and LoRa: the software solution to create high availability with minimal security risks
Today, the number of Internet of Things (IoT) devices in all aspects of life is increasing exponentially. Our cities are getting smarter and informing us about our surroundings in a contextual manner. However, we face significant challenges in deploying, managing, and collecting data from these devices. In addition, we must address the problem of storing and mining that data for higher-quality IoT services. Blockchain technology, even in today's nascent form, has the potential to be the foundation for a common, distributed, trustless, and autonomous infrastructure system. This article describes a standardized IoT infrastructure where data are stored on a distributed storage service that is fault-tolerant and resistant to distributed denial of service (DDOS) attacks and data access is managed by a decentralized, trustless blockchain. The illustrated system used LoRa as the emerging network technology, Swarm as the distributed data storage platform, and Ethereum as the blockchain platform. Such a data back end will ensure high availability with minimal security risks while replacing traditional back-end systems with a single "smart contract."

Integrating low-power IoT devices to a blockchain-based infrastructure: work-in-progress
The ever-increasing number of IoT devices necessitates a secure and scalable infrastructure to store and process generated data. Blockchain is an ideal choice with its decentralized, trustless architecture. However, low-power IoT end-devices do not possess enough horsepower to run a software client for intensive blockchain calculations. The purpose of this paper is to create a proof of concept to enable low-power, resource-constrained IoT end-devices accessing a blockchain-based infrastructure. To achieve this aim, an IoT gateway is configured as a blockchain node and an event-based messaging mechanism for low-power IoT end-devices is proposed. A demonstration of such a system is realized using LoRa nodes and gateway in a private Ethereum network.

An algorithm for the design of low-power hardware-efficient FIR filters
A novel algorithm for designing low-power and hardware-efficient linear-phase finite-impulse response (FIR) filters is presented. The algorithm finds filter coefficients with reduced number of signed-power-of-two (SPT) terms given the filter frequency response characteristics. The algorithm is a branch-and-bound-based algorithm that fixes a coefficient to a certain value. The value is determined by finding the boundary values of the coefficient using linear programming. Although the worst case run time of the algorithm is exponential, its capability to find appreciably good solutions in a reasonable amount of time makes it a desirable CAD tool for designing low-power and hardware-efficient filters. The superiority of the algorithm on existing methods in terms of SPT term count, design time, hardware complexity, and power performance is shown with several design examples. Up to 30% reduction in the number of SPT terms is achieved over unoptimized Remez coefficients, which is 20% better than compared optimization methods. The average power saving is 20% over unoptimized coefficients, which is up to 14% better than optimized coefficients obtained with existing methods.

Efficient implementations of multi-pumped multi-port register files in FPGAs
Existing implementation methods of multi-port register files (MPo-RF) in FPGAs are not scalable enough to deal with the increased number of ports due to higher logic area and power. While the usage of dedicated block RAMs (BRAMs) limits the designer to use only single read and single write port, slice based approach causes large resource occupation and degrades design performance significantly. Similarly, the conventional multi-pumping (MPu) approaches are not efficient enough due to increased combinational delay and area of huge multiplexers. In this paper, we propose a new design which exploits the banking and replication of BRAMs with efficient shift register based multi-pumping (SR-MPu) approach. While increased port number causes internal frequency drops in conventional multiplexer based MPu approaches, it does not affect internal operating frequency of our SR-MPu methodology. Test results on Xilinx Virtex-5 XC5VLX110T FPGA show that our 32-bit 12-read & 6-write (12R&6W) RF can operate internally up to 429 Mhz while 64-bit version up to 408 Mhz. The speed of our RF is independent from MPu factor and occupies lower logic resources up to 47% when compared with other design methods. In terms of energy consumption, our RF design saves energy up to 26% according to the Xilinx Power Analyzer (XPA) results.

Multiplierless realization of linear DSP transforms by using common two-term expressions
AxleDB: A novel programmable query processing platform on FPGA
Dynamic partial self-reconfiguration on spartan-iii fpgas via a parallel configuration access port (pcap)
This paper presents an alternative approach for dynamic partial self-reconfiguration that enables a Field Programmable Gate Array (FPGA) to reconfigure itself dynamically and partially through a parallel configuration access port (PCAP) under the control of the stand alone PCAP core within the FPGA instead of using an embedded processor. The reconfiguration process is accomplished without an internal configuration access port(ICAP), which should be used either with MicroBlaze soft core or with PowerPC hard core using HWICAP core for the OnChip Peripheral Bus (OPB)[6]. However, the stand alone PCAP core needs neither HWICAP core nor the OPB bus interface. The PCAP core needs only 324 slices, which is approximately 16% of a Spartan3S200 FPGA. The dynamic partial self-reconfiguration via PCAP core works up to 50Mbyte/s. This approach has been implemented on a pure Spartan-3 FPGA from Xilinx, but it can also be used for any other FPGA architectures, such as Virtex-II(Pro), Virtex-4, Virtex-5, etc.

Self-reconfiguration on Spartan-III FPGAs with compressed partial bitstreams via a parallel configuration access port (cPCAP) core
This paper presents an alternative approach for dynamic partial self-reconfiguration that enables a field programmable gate array (FPGA) to reconfigure itself at run-time partially through a parallel configuration access port (cPCAP) under the control of the stand alone cPCAP core within the FPGA instead of using an embedded processor. The cPCAP core with bitstream decompression module needs only 361 slices, which is approximately 18% of a Spartan-3S200 FPGA. The dynamic partial self-reconfiguration via cPCAP core works up to 50 Mbyte/s. The compressed partial bitstream is stored in BlockRAM within the FPGA and decompressed via cPCAP core at the time of reconfiguration of the FPGA. This approach has been implemented on a pure Spartan-3 FPGA from Xilinx, but it can also be used for any other FPGA architectures, such as Virtex-II(Pro), Virtex-4, Virtex-5, etc.

Approximate CPU design for IoT end-devices with learning capabilities
With the rise of Internet of Things (IoT), low-cost resource-constrained devices have to be more capable than traditional embedded systems, which operate on stringent power budgets. In order to add new capabilities such as learning, the power consumption planning has to be revised. Approximate computing is a promising paradigm for reducing power consumption at the expense of inaccuracy introduced to the computations. In this paper, we set forth approximate computing features of a processor that will exist in the next generation low-cost resource-constrained learning IoT devices. Based on these features, we design an approximate IoT processor which benefits from RISC-V ISA. Targeting machine learning applications such as classification and clustering, we have demonstrated that our processor reinforced with approximate operations can save power up to 23% for ASIC implementation while at least 90% top-1 accuracy is achieved on the trained models and test data set.

Introducing hardware-in-loop concept to the hardware/software co-design of real-time embedded systems
As the need for embedded systems to interact with other systems is growing fast, we see great opportunities in introducing the hardware-in-the-loop technique to the field of hardware/software co-design of embedded systems. This technique reduces the need to develop models for existing hardware and increases the accuracy of the overall system. This work is especially important now that complexity and time-to-market constraints demand early simulation, verification, and architectural exploration of systems. We introduce the hardware-in-the loop technique to the field of hardware/software co-design of industrial embedded systems using SystemC as the modeling environment. We conceptualize the hybrid channel to clearly define the communication between real and virtual (modeled) subsystems. We patch the SystemC kernel for hard real-time execution and we improve the underlying operating system to guarantee an upper bound for the overall system latency. We have performed tests to measure the performance of our method in terms of response time and determinism. We have achieved a stable operating frequency of 10 KHz and an I/O performance of sub-millisecond round-trip time over Ethernet. Moreover we have developed a non-timed transaction-level model of a BACnet Broadcast Management Device (BBMD) and connected it with real devices to see our method's performance in a real-life environment. Our model outperformed the competing real system up to 80 times in maximum response time. We deem the results very promising for the future of our method.

Fractions in the canonical-signed-digit number system
Canonical-signed-digit (CSD) coefficient representations lead to efficient add/subtract networks for hardwired DSP multiplies of two’s complement signals. CSD has always been considered a fixed-point system, and available conversion algorithms operate on integers. Using methods applicable to many simple number systems, we rederive CSD for fractional numbers, derive a simple floating-point recursion for converting fractions to CSD, and briefly examine the associated truncation error.

High level synthesis based hardware accelerator design for processing SQL queries
About three exabytes of data is created and stored in databases each day, and this number is doubling approximately every forty months. Querying this enormous amount of data has been a challenge and new methods have been actively researched. In this paper, we present hardware accelerators which are designed to speed up database analytics for in-memory databases. Unlike traditional hardware accelerator designs, our hardware accelerators are composed using High Level Synthesis (HLS), which enables high level descriptions of functionality such as data filtering, sorting, equijoins to be targeted directly into RTL. We have simulated TPC-H benchmark queries using Xilinx Vivado HLS managed in our custom simulation software framework. Our results have demonstrated the capabilities of HLS in database acceleration domain; such that the 200MHz FPGA accelerator can provide two orders of magnitude performance improvement compared to PostgreSQL based full software implementation running on a modern multicore system.

Application specific multi-port memory customization in FPGAs
FPGA block RAMs (BRAMs) offer speed advantages compared to LUT-based memory designs but a BRAM has only one read and one write port. Designers need to use multiple BRAMs in order to create multi-port memory structures which are more difficult than designing with LUT-based multiport memories. Multi-port memory designs increase overall performance but comes with area cost. In this paper, we present a fully automated methodology that tailors our multi-port memory from a given application. We present our performance improvements and area tradeoffs on state-of-the-art string matching algorithms.

An efficient heterogeneous register file implementation for FPGAs
For the future of computing, wide usage of heterogeneous architecture is indispensable since advances in technology scaling cannot satisfy the expected increase in performance of computational platforms anymore. FPGA is a promising platform for heterogeneous computing due to its configurable structure. Each part of an FPGA can be configured to perform a different task that it is best suited for. Such a heterogeneous system needs a common register file (RF) that can serve different parts of the FPGA with at different characteristics in terms of running frequency, data consumption/production rate, required number of ports, data widths, address spaces and endianness. In this study, we propose a heterogeneous register file (HRF) architecture for FPGA-based heterogeneous systems. The designed register file uses a heterogeneous multi-port base-RF to provide such heterogeneity. For the power and area reduction, the design takes advantage of frequency differences between processing elements and HRF by an efficient multi-pumping system. According to the literature, this is the first study on FPGA-based heterogeneous RFs. For experimentation, HRF is tested in four different heterogeneous architectures with increasing complexity. For all HRF configurations, speed, area and energy are measured. Test results of the HRF on Xilinx Virtex-5 show that our heterogeneous register file outperforms other RF architectures implemented by conventional methods.

Fast and efficient algorithm for the multiplierless realisation of linear DSP transforms
In this paper, a fast algorithm having a pseudopolynomial run-time and memory requirement in the worst-case is developed to generate multiplierless architectures at all wordlengths for constant multiplications in linear DSP transforms. It is also re-emphasized that indeﬁnitely reducing operators for multiplierless architectures is not suﬃcient to reduce the ﬁnal chip area. For a major reduction, techniques like resource folding must be used. Simple techniques for improving the results are also presented.

An efficient mapping algorithm on 2-d mesh network-on-chip with reconfigurable switches
As Network-on-Chips (NoC) are the most scalable architecture with growing number of processing elements in multi-core systems, communication data between nodes tend to travel through more routers. Hence, a good mapping algorithm must be designed in order to locate most communicating nodes neighbour to each other. However, this may not be sufficient for data-intensive applications such as audio, video, telecommunication and etc. In such multi-core applications, processing elements communicate to each other with heavy load statically in most cases. Passing heavy load data through routers might make the routers bottleneck of the system. In this paper, we propose a custom 2-D NoC architecture with simple reconfigurable switches, which can be configured during both design and runtime according to the application requirements. We designed a mapping algorithm which tries to set paths through these simple switches instead of complicated routers all the way. Experimental results show that our mapping algorithm reduces routing cost up to by 79.96% for real life embedded applications.

A self-reconfigurable platform for general purpose image processing systems on low-cost spartan-6 FPGAs
There is still no partial reconfiguration tool support on low-cost Field Programmable Gate Arrays (FPGAs) such as old-fashioned Spartan-3 and state-of-the-art Spartan-6 FPGA families by Xilinx. This forces the designers and engineers, who are using the partial reconfiguration capability of FPGAs, to use expensive families such as Virtex-4, Virtex-5 and Virtex-6 which are officially supported by partial reconfiguration (PR) software. Moreover, Xilinx still does not offer a portable, dedicated self-reconfiguration engine for all of the FPGAs. Self-reconfiguration is achieved with general-purpose processors such as MicroBlaze and PowerPC which are too overqualified for this purpose. In this study, we propose a new self-reconfiguration mechanism for Spartan-6 FPGAs. This mechanism can be used to implement large and complex designs on small FPGAs as chip area can be dramatically reduced by exploiting the dynamic partial reconfiguration feature for on-demand functionality loading and maximal utilization of the hardware. This approach is highly attractive for designing low-cost compute-intensive applications such as high performance image processing systems. For Spartan-6 FPGAs, we have developed hard-macros and exploited the self-reconfiguration engine, compressed Parallel Configuration Access Port (cPCAP) [1], that we designed for Spartan-3. The modified cPCAP core with block RAM controller, bitstream decompressor unit and Internal Configuration Access Port (ICAP) Finite State Machine (FSM) occupies only about 82 of 6,822 slices (1.2% of whole device) on a Spartan-XC6SLX45 FPGA and it achieves the maximum theoretical reconfiguration speed of 200MB/s (ICAP, 16-bit at 100MHz) proposed by Xilinx. We have also implemented a Reconfigurable Processing Element (RPE) whose arithmetic unit can be reconfigured on-the-fly. Multiple RPEs can be utilized to design a General Purpose Image Processing System (GPIPS) that can implement a number of different algorithms during runtime. As an illustrative example, we programmed the GPIPS on Spartan-6 for switching between two applications on-demand such as two-dimensional filtering and block-matching.

A heterogeneous simulation and modeling framework for automation systems
Recently, new technologies have emerged in industrial automation platforms. A rapid modeling and simulation environment is required to integrate these new technologies with existing devices and platforms to reduce the design effort and time to market. System-level modeling is a popular design technique that provides early simulation, verification, and architectural exploration. However, integration of real devices with system models is quite challenging due to synchronization and hard real-time constraints in industrial automation. SystemC is the most commonly used system-level language in hardware-software codesign. However, SystemC lacks interfaces for the integration of system (virtual) models with real (physical) devices. We introduce the hybrid channel concept to clearly define the integration interface. Hybrid channel incorporates both real-to-virtual and virtual-to-real communication functions by solving synchronization issues while satisfying the real-time constraints. We successfully demonstrated the usability of our framework in industrial systems that utilize BACNet and Ethernet. We also developed a mathematical model that correctly estimates the results of our experiments. To the best of our knowledge, this is the first framework and mathematical model for SystemC in industrial automation domain.

Multiplierless implementation of 2-D FIR filters
DONE