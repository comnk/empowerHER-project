What is keeping my phone awake?: characterizing and detecting no-sleep energy bugs in smartphone apps
Despite their immense popularity in recent years, smartphones are and will remain severely limited by their battery life. Preserving this critical resource has driven smartphone OSes to undergo a paradigm shift in power management: by default every component, including the CPU, stays off or in an idle state, unless the app explicitly instructs the OS to keep it on! Such a policy encumbers app developers to explicitly juggle power control APIs exported by the OS to keep the components on, during their active use by the app and off otherwise. The resulting power-encumbered programming unavoidably gives rise to a new class of software energy bugs on smartphones called no-sleep bugs, which arise from mis-handling power control APIs by apps or the framework and result in significant and unexpected battery drainage.
 This paper makes the first advances towards understanding and automatically detecting software energy bugs on smartphones. It makes the following three contributions: (1) we present the first comprehensive study of real world no-sleep energy bug characteristics; (2) we propose the first automatic solution to detect these bugs based on the classic reaching definitions dataflow analysis algorithm; (3) we provide experimental data showing that our tool accurately detected all 17 known instances of no-sleep bugs and found 34 new bugs in the 73 apps examined.

Smartphone energy drain in the wild: Analysis and implications
Multi-objective optimization and decision making approaches to cricket team selection
Smartphone Background Activities in the Wild: Origin, Energy Drain, and Optimization
As new iterations of more powerful and better connected smartphones emerge, their limited battery life remains a leading factor adversely affecting the mobile experience of millions of smartphone users. While it is well-known that many apps can drain battery even while running in background, there has not been any study that quantifies the extent and severity of such background energy drain for users in the wild. To extend battery life, various new features are being incorporated within the phone, one of them being preventing applications from running in background, i.e., when the screen is off, but their impact is largely unknown. This paper makes several contributions. First, we present a large-scale measurement study that performs an in-depth analysis of the activities of various apps running in background on thousands of phones in the wild. Second, we quantify the amount of battery drain by all such background activities and possible energy saving. Third, we develop a metric to measure the usefulness of background activities that is personalized to each user. Finally, we present a system called HUSH (screen-off optimizer) that monitors the metric online and automatically identifies and suppresses background activities during screen-off periods that are not useful to the user experience. In doing so, our proposed HUSH saves screen-off energy of smartphones by 15.7% on average while incurring minimal impact on the user experience with the apps.

Energy and Performance of Smartphone Radio Bundling in Outdoor Environments
Most of today's mobile devices come equipped with both cellular LTE and WiFi wireless radios, making radio bundling (simultaneous data transfers over multiple interfaces) both appealing and practical. Despite recent studies documenting the benefits of radio bundling with MPTCP, many fundamental questions remain about potential gains from radio bundling, or the relationship between performance and energy consumption in these scenarios. In this study, we seek to answer these questions using extensive measurements to empirically characterize both energy and performance for radio bundling approaches. In doing so, we quantify potential gains of bundling using MPTCP versus an ideal protocol. We study the links between traffic partitioning and bundling performance, and use a novel componentized energy model to quantify the energy consumed by CPUs (and radios) during traffic management. Our results show that MPTCP achieves only a fraction of the total performance gain possible, and that its energy-agnostic design leads to considerable power consumption by the CPU. We conclude that not only there is room for improved bundling performance, but an energy-aware bundling protocol is likely to achieve a much better tradeoff between performance and power consumption.

Hypnos: understanding and treating sleep conflicts in smartphones
To maximally conserve the critical resource of battery energy, smartphone OSes implement an aggressive system suspend policy that suspends the whole system after a brief period of user inactivity. This burdens developers with the responsibility of keeping the system on, or waking it up, to execute time-sensitive code. Developer mistakes in using the explicit power management unavoidably give rise to energy bugs, which cause significant, unexpected battery drain.
 In this paper, we study a new class of energy bugs, called sleep conflicts, which can happen in smartphone device drivers. Sleep conflict happens when a component in a high power state is unable to transition back to the base power state because the system is suspended when the device driver code responsible for driving the transition is supposed to execute. We illustrate the root cause of sleep conflicts, develop a classification of the four types of sleep conflicts, and finally present a runtime system that performs sleep conflict avoidance, along with a simple yet effective pre-deployment testing scheme. We have implemented and evaluated our system on two Android smartphones. Our testing scheme detects several sleep conflicts in WiFi and vibrator drivers, and our runtime avoidance scheme effectively prevents sleep conflicts from draining the battery.

Cricket team selection using evolutionary multi-objective optimization
How much energy can we save from prefetching ads? Energy drain analysis of top 100 apps
Recently, there has been a surge of interests on developing techniques and architectures for prefetching ads to potentially reduce the smartphone energy drain by 3G/4G radios from fetching ads. Despite the development of prefetching techniques, it remains unclear (1) how much smartphone energy do ads consume in popular apps in dominant app markets, and (2) out of which, what portion can we realistically save from prefetching?
 We present a measurement study of the energy drain of top 100 free apps in Google Play, totaling more than 2.2 B downloads, to re-examine the above two motivational questions for ads energy research. We found the upper bound energy savings from prefetching ads is low: out of the top 100 apps, only 57 apps display ads, which incur on average 3.2% total energy on ads 3G tails. We further show the already-low upper bound ads energy saving is hard to achieve by ads prefetching as different apps exhibit very different ads behavior.

Systems and methods of detecting power bugs
Power consumption has become a major design constraint, especially for battery-powered embedded systems. However, the impact of software applications is typically considered in later phases, where both software and hardware parts are close to their finalization. Power-related issues must be detected in early stages to keep the development costs low, satisfy time-to-market, and avoid cost-intensive redesign loops. Moreover, the variety of hardware components, architectures, and communication interfaces make the development of embedded software more challenging. To manage the complexity of software applications, approaches such as model-driven development (MDD) may be used. This article proposes a power-estimation approach in MDD for software application models in early development phases. A unified modeling language (UML) profile is introduced to model power-related properties of hardware components. To determine the impact of software applications, we defined two analysis methods using simulation data and a novel in-the-loop concept. Both methods may be applied at different development stages to determine an energy trace, describing the energy-related behavior of the system. A novel definition of energy bugs is provided to describe power-related misbehavior. We apply our approach to a sensor node example, demonstrate an energy bug detection, and compare the runtime and accuracy of the analysis methods.

On death, taxes, and sleep disorder bugs in smartphones
According to Benjamin Franklin, life holds but two certainties, death and taxes. As we enter the mobile era, the primary mobile device, i.e., the smartphone, faces the certainties of adopting agressive sleeping polices to conserve battery energy, requiring programmers to use explicit power control APIs to keep the SOC/CPU on, and a third certainty that unavoidably rises from these: sleep disorder bugs.
 In this paper, we articulate the fate and destiny of smartphone apps, sleep disorder bugs, as a critical technical challenge in the mobile era. We then present a taxonomy of sleep disorder bugs, and a categorization of time-critical sections which are the root cause of sleep disorders, in apps, framework services and the Android kernel. Finally, we present a unified system for detecting the spectrum of sleep disorder bugs.

Differential energy profiling: energy optimization via diffing similar apps
Mobile app energy profilers provide a foundational energy diagnostic tool by identifying energy hotspots in the app source code. However, they only tackle the first challenge faced by developers, as, after presented with the energy hotspots, developers typically do not have any guidance on how to proceed with the remaining optimization process: (1) Is there a more energy-efficient implementation for the same app task? (2) How to come up with the more efficient implementation? 
 
To help developers tackle these challenges, we developed a new energy profiling methodology called differential energy profiling that automatically uncovers more efficient implementations of common app tasks by leveraging existing implementations of similar apps which are bountiful in the app marketplace. To demonstrate its effectiveness, we implemented such a differential energy profiler, DIFFPROF, for Android apps and used it to profile 8 groups (from 6 popular app categories) of 5 similar apps each. Our extensive case studies show that DIFFPROF provides developers with actionable diagnosis beyond a traditional energy profiler: it identifies non-essential (unmatched or extra) and known-to-be inefficient (matched) tasks, and the call trees of tasks it extracts further allow developers to quickly understand the reasons and develop fixes for the energy difference with minor manual debugging efforts.

Differential resource profiling with actionable diagnostics
Lassa fever virus (LASV) causes acute viral haemorrhagic fever with symptoms similar to those seen with Ebola virus infections. LASV is endemic to West Africa and is transmitted through contact with excretions of infected Mastomys natalensis rodents and other rodent species. Due to a high fatality rate, lack of treatment options and difficulties with prevention and control, LASV is one of the high-priority pathogens included in the WHO R&D Blueprint. The WHO LASV vaccine strategy relies on availability of effective diagnostic tests. Current diagnostics for LASV include in-house and commercial (primarily research-only) laboratory-based serological and nucleic acid amplification tests. There are two commercially available (for research use only) rapid diagnostic tests (RDTs), and a number of multiplex panels for differential detection of LASV infection from other endemic diseases with similar symptoms have been evaluated. However, a number of diagnostic gaps remain. Lineage detection is a challenge due to the genomic diversity of LASV, as pan-lineage sensitivity for both molecular and immunological detection is necessary for surveillance and outbreak response. While pan-lineage ELISA and RDTs are commercially available (for research use only), validation and external quality assessment (EQA) is needed to confirm detection sensitivity for all known or relevant strains. Variable sensitivity of LASV PCR tests also highlights the need for improved validation and EQA. Given that LASV outbreaks typically occur in low-resource settings, more options for point-of-care testing would be valuable. These requirements should be taken into account in target product profiles for improved LASV diagnostics.

Experience: developing a usable battery drain testing and diagnostic tool for the mobile industry
In this paper, we report on our 6-year experience developing Eagle Tester (eTester for short) - a mobile battery drain testing and diagnostic tool. We show how eTester evolved from an "academic" prototype to a fully automated tool usable by the mobile industry. We first present the design of our initial research prototype and discuss 8 key requirements for a usable battery drain testing and diagnostic tool gathered from some of the most popular software vendors in the Android ecosystem. These requirements posed interesting scientific and engineering challenges such as how to accurately estimate battery drain without requiring a priori power modeling, work on unmodified devices, and automatically monitor code evolution to generate high-fidelity battery spike alerts with actionable insights. These requirements motivated a complete overhaul of the eTester design and led to the creation of a novel battery drain testing methodology. We show how the redesigned eTester was used to effortlessly find battery bugs in some of the most popular Android apps with hundreds of millions of users, such as Netflix and CNN. We are open-sourcing eTester to encourage further research in battery diagnosis and to empower developers to write battery-efficient mobile software.

Unsafe time handling in smartphones
Time manipulation, typically done using gettime() and settime(), happens extensively across all software layers in smartphones, from the kernel, to the framework, to millions of apps. This paper presents the first study of a new class of software bugs on smartphones called sleep-induced time bugs (SITB). SITB happens when the phone is suspended, due to the aggressive sleeping policy adopted in smartphones, in the middle of a time critical section where time is being manipulated and delay caused by unexpected phone suspension alters the intended program behavior. 
 
We first characterize time usages in the Android kernel, framework, and 978 apps into four categories and study their vulnerabilities to system suspension. Our study shows time manipulation happens extensively in all three software layers, totaling 1047, 1737 and 7798 times, respectively, and all four usage patterns are vulnerable to SITBs. We then present a tool called KLOCK, that makes use of a set of static analyses to systematically identify sleep-induced time bugs in three of the four time usage categories. When applied to five different Android Linux kernels, KLOCK correctly flagged 63 SITB-vulnerable time manipulation instances as time bugs.

Systems and methods of detecting power bugs
Power consumption has become a major design constraint, especially for battery-powered embedded systems. However, the impact of software applications is typically considered in later phases, where both software and hardware parts are close to their finalization. Power-related issues must be detected in early stages to keep the development costs low, satisfy time-to-market, and avoid cost-intensive redesign loops. Moreover, the variety of hardware components, architectures, and communication interfaces make the development of embedded software more challenging. To manage the complexity of software applications, approaches such as model-driven development (MDD) may be used. This article proposes a power-estimation approach in MDD for software application models in early development phases. A unified modeling language (UML) profile is introduced to model power-related properties of hardware components. To determine the impact of software applications, we defined two analysis methods using simulation data and a novel in-the-loop concept. Both methods may be applied at different development stages to determine an energy trace, describing the energy-related behavior of the system. A novel definition of energy bugs is provided to describe power-related misbehavior. We apply our approach to a sensor node example, demonstrate an energy bug detection, and compare the runtime and accuracy of the analysis methods.

Colour image compression by grey to colour conversion
Instead of de-correlating image luminance from chrominance, some use has been made of using the correlation between the luminance component of an image and its chromatic components, or the correlation between colour components, for colour image compression. In one approach, the Green colour channel was taken as a base, and the other colour channels or their DCT subbands were approximated as polynomial functions of the base inside image windows. This paper points out that we can do better if we introduce an addressing scheme into the image description such that similar colours are grouped together spatially. With a Luminance component base, we test several colour spaces and rearrangement schemes, including segmentation. and settle on a log-geometric-mean colour space. Along with PSNR versus bits-per-pixel, we found that spatially-keyed s-CIELAB colour error better identifies problem regions. Instead of segmentation, we found that rearranging on sorted chromatic components has almost equal performance and better compression. Here, we sort on each of the chromatic components and separately encode windows of each. The result consists of the original greyscale plane plus the polynomial coefficients of windows of rearranged chromatic values, which are then quantized. The simplicity of the method produces a fast and simple scheme for colour image and video compression, with excellent results.

An Empirical Study on the Impact of Deep Parameters on Mobile App Energy Usage
Improving software performance through configuration parameter tuning is a common activity during software maintenance. Beyond traditional performance metrics like latency, mobile app developers are interested in reducing app energy usage. Some mobile apps have centralized locations for parameter tuning, similar to databases and operating systems, but it is common for mobile apps to have hundreds of parameters scattered around the source code. The correlation between these “deep” parameters and app energy usage is unclear. Researchers have studied the energy effects of deep parameters in specific modules, but we lack a systematic understanding of the energy impact of mobile deep parameters. In this paper we empirically investigate this topic, combining a developer survey with systematic energy measurements. Our motivational survey of 25 Android developers suggests that developers do not understand, and largely ignore, the energy impact of deep parameters. To assess the potential implications of this practice, we propose a deep parameter energy profiling framework that can analyze the energy impact of deep parameters in an app. Our framework identifies deep parameters, mutates them based on our parameter value selection scheme, and performs reliable energy impact analysis. Applying the framework to 16 popular Android apps, we discovered that deep parameter-induced energy inefficiency is rare. We found only 2 out of 1644 deep parameters for which a different value would significantly improve its app's energy efficiency. A detailed analysis found that most deep parameters have either no energy impact, limited energy impact, or an energy impact only under extreme values. Our study suggests that it is generally safe for developers to ignore the energy impact when choosing deep parameter values in mobile apps.

App Parameter Energy Profiling: Optimizing App Energy Drain by Finding Tunable App Parameters
In this paper, we observe that modern mobile apps come with a large number of parameters that control the app behavior which indirectly affect the app energy drain, and using incorrect or non-optimal values for such app parameters can lead to app energy drain deficiency or even energy bugs. We argue conventional app energy optimization using an energy profiler which pinpoints energy hotspot code segments in the app source code may be ineffective in detecting such parameter-induced app energy deficiency. We propose app parameter energy profiling which identifies tunable app parameters that can reduce app energy drain without affecting app functions as a potentially more effective solution for debugging such app energy deficiency. We present the design and implementation of Medusa, an app parameter energy profiling framework. Medusa overcomes three key design challenges: how to filter out and narrow down candidate parameters, how to pick alternative parameter values, and how to perform reliable energy drain testing of app versions with mutated parameter values. We demonstrate the effectiveness of Medusa by applying it to a set of Android apps which successfully identifies tunable energy-reducing parameters.

Towards Automated Energy Debugging on Smartphones
Reactive Dataflow for Inflight Error Handling in ML Workflows
Modern data analytics pipelines comprise traditional data transformation operations and pre-trained ML models deployed as user-defined functions (UDFs). Such pipelines, which we call ML workflows, generally produce erroneous results due to data errors inadvertently introduced by ML models. Model errors are one of the main obstacles to improved accuracy of ML workflows. In this paper, we present Popper, a dataflow system---for expressing ML workflows---that natively supports inflight error handling. Users can extend ML workflows expressed in Popper by plugging in error handlers to improve accuracy. We propose reactive dataflow, a novel cyclic graph-based dataflow model that provides convenient abstractions for interleaving dataflow operators with user-defined error handlers for detecting and correcting errors on the fly. We also propose an efficient execution strategy amenable to pipeline parallel execution of reactive dataflow. We discuss open research challenges for making error handling a first-class citizen in dataflow systems and present preliminary evaluation of our prototypical system, which shows the effectiveness and benefits of inflight error handling in ML workflows.

DONE