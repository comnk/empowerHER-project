The undecidability of the semi-unification problem
Abstract The Semi-Unification Problem (SUP) is a natural generalization of both first-order unification and matching. The problem arises in various branches of computer science and logic. Although several special cases of SUP are known to be decidable, the problem in general has been open for several years. We show that SUP in general is undecidable, by reducing what we call the "boundedness problem" of Turing machines to SUP. The undecidability of this boundedness problem is established by a technique developed in the mid-1960s to prove related results about Turing machines

A programming approach to computability
Type reconstruction in the presence of polymorphic recursion
We study the problem of type-checking functional programs in three extensions of ML. One distinguishing feature of these extensions is that they allow recursive definitions to be polymorphically typed. Although the motivation for these extensions comes from pragmatic considerations of programming language design, we show that the typability problem for each one of these extensions is polynomial-time equivalent to the Semi-Unification Problem and, therefore, undecidable

An introduction to formal language theory
An analysis of ML typability
We carry out an analysis of typability of terms in ML. Our main result is that this problem is DEXPTIME-hard, where by DEXPTIME we mean DTIME(2n0(1)). This, together with the known exponential-time algorithm that solves the problem, yields the DEXPTIME-completeness result. This settles an open problem of P. Kanellakis and J. C. Mitchell.
Part of our analysis is an algebraic characterization of ML typability in terms of a restricted form of semi-unification, which we identify as acyclic semi-unification. We prove that ML typability and acyclic semi-unification can be reduced to each other in polynomial time. We believe this result is of independent interest.

Principality and decidable type inference for finite-rank intersection types
Principality of typings is the property that for each typable term, there is a typing from which all other typings are obtained via some set of operations. Type inference is the problem of finding a typing for a given term, if possible. We define an intersection type system which has principal typings and types exactly the strongly normalizable ¿-terms. More interestingly, every finite-rank restriction of this system (using Leivant's first notion of rank) has principal typings and also has decidable type inference. This is in contrast to System F where the finite rank restriction for every finite rank at 3 and above has neither principal typings nor decidable type inference. This is also in contrast to earlier presentations of intersection types where the status (decidable or undecidable) of these properties is unknown for the finite-rank restrictions at 3 and above. Furthermore, the notion of principal typings for our system involves only one operation, substitution, rather than several operations (not all substitution-based) as in earlier presentations of principality for intersection types (without rank restrictions). In our system the earlier notion of expansion is integrated in the form of expansion variables, which are subject to substitution as are ordinary variables. A unification-based type inference algorithm is presented using a new form of unification, ß-unification.

A direct algorithm for type inference in the rank-2 fragment of the second-order λ-calculus
We examine the problem of type inference for a family of polymorphic type systems containing the power of Core-ML. This family comprises the levels of the stratification of the second-order λ-calculus (system F) by “rank” of types. We show that typability is an undecidable problem at every rank k≥3. While it was already known that typability is decidable at rank 2, no direct and easy-to-implement algorithm was available. We develop a new notion of λ-term reduction and use it to prove that the problem of typability at rank 2 is reducible to the problem of acyclic semi-unification. We also describe a simple procedure for solving acyclic semi-unification. Issues related to principle types are discussed.

A linearization of the lambda-calculus and consequences
Abstract If every lambda-abstraction in a lambda-term M binds at most one variable occurrence, then M is said to be "linear". Many questions about linear lambda-terms are relatively easy to answer, e.g. they all are beta-strongly normalizing and all are simply-typable. We extend the syntax of the standard lambda-calculus L to a non-standard lambda-calculus L^ satisfying a linearity condition generalizing the notion in the standard case. Specifically, in L^ a subterm Q of a term M can be applied to several subterms R1,...,Rk in parallel, which we write as (Q. R1 \wedge ... \wedge Rk). The appropriate notion of beta- reduction beta^ for the calculus L^ is such that, if Q is the lambda- abstraction (\lambda x.P) with m\geq 0 bound occurrences of x, the reduction can be carried out provided k = max(m,1). Every M in L^ is thus beta^-SN. We relate standard beta-reduction and non-standard beta^-reduction in several different ways, and draw several consequences, e.g. a new simple proof for the fact that a standard term M is beta-SN iff M can be assigned a so-called ``intersection'''' type (``top'''' type disallowed).

Principality and type inference for intersection types using expansion variables
ML typability is DEXPTIME-complete
A well known but incorrect piece of functional programming folklore is that ML expressions can be efficiently typed in polynomial time. In probing the truth of that folklore, various researchers, including Wand, Buneman, Kanellakis, and Mitchell, constructed simple counterexamples consisting of typable ML programs having length n, with principal types having &OHgr;(2cn) distinct type variables and length &OHgr;(22cn). When the types associated with these ML constructions were represented as directed acyclic graphs, their sizes grew as &OHgr;(2cn). The folklore was even more strongly contradicted by the recent result of Kanellakis and Mitchell that simply deciding whether or not an ML expression is typable is PSPACE-hard.
We improve the latter result, showing that deciding ML typability is DEXPTIME-hard. As Kanellakis and Mitchell have shown containment in DEXPTIME, the problem is DEXPTIME-complete. The proof of DEXPTIME-hardness is carried out via a generic reduction: it consists of a very straightforward simulation of any deterministic one-tape Turing machine M with input &khgr; running in &Ogr;(c|&khgr;|) time by a polynomial-sized ML formula &PHgr;M,&khgr;, such that M accepts &khgr; iff &PHgr;M,&khgr; is typable. The simulation of the transition function δ of the Turing Machine is realized uniquely through terms in the lambda calculus without the use of the polymorphic let construct. We use let for two purposes only: to generate an exponential amount of blank tape for the Turing Machine simulation to begin, and to compose an exponential number of applications of the ML formula simulating state transition.
It is purely the expressive power of ML polymorphism to succinctly express function composition which results in a proof of DEXPTIME-hardness. We conjecture that lower bounds on deciding typability for extensions to the typed lambda calculus can be regarded precisely in terms of this expressive capacity for succinct function composition.
To further understand this lower bound, we relate it to the problem of proving equality of type variables in a system of type equations generated from an ML expression with let-polymorphism. We show that given an oracle for solving this problem, deciding typability would be in PSPACE, as would be the actual computation of the principal type of the expression, were it indeed typable.

New notions of reduction and non-semantic proofs of strong/spl beta/-normalization in typed/spl lambda/-calculi
Two notions of reduction for terms of the /spl lambda/-calculus are introduced and the question of whether a /spl lambda/-term is /spl beta/-strongly normalizing is reduced to the question of whether a /spl lambda/-term is merely normalizing under one of the notions of reduction. This gives a method to prove strong /spl beta/-normalization for typed /spl lambda/-calculi. Instead of the usual semantic proof style based on Tait's realizability or Girard's "candidats de reductibilite", termination can be proved using a decreasing metric over a well-founded ordering. This proof method is applied to the simply-typed /spl lambda/-calculus and the system of intersection types, giving the first non-semantic proof for a polymorphic extension of the /spl lambda/-calculus.

A basis for theoretical computer science
Type reconstruction in finite rank fragments of the second-order λ-calculus
Verifiably-safe software-defined networks for CPS
Next generation cyber-physical systems (CPS) are expected to be deployed in domains which require scalability as well as performance under dynamic conditions. This scale and dynamicity will require that CPS communication networks be programmatic (i.e., not requiring manual intervention at any stage), but still maintain iron-clad safety guarantees. Software-defined networking standards like Openflow provide a means for scalably building tailor-made network architectures, but there is no guarantee that these systems are safe, correct, or secure. In this work we propose a methodology and accompanying tools for specifying and modeling distributed systems such that existing formal verification techniques can be transparently used to analyze critical requirements and properties prior to system implementation. We demonstrate this methodology by iteratively modeling and verifying an Openflow learning switch network with respect to network correctness, network convergence, and mobility-related properties.
 We posit that a design strategy based on the complementary pairing of software-defined networking and formal verification would enable the CPS community to build next-generation systems without sacrificing the safety and reliability that these systems must deliver.

A verification platform for SDN-enabled applications
Recent work on integration of SDNs with application-layer systems like Hadoop has created a class of system, SDN-Enabled Applications, which implement application-specific functionality on the network layer by exposing network monitoring and control semantics to application developers. This requires domain-specific knowledge to correctly reason about network behavior and properties, as the SDN is now tightly coupled to the larger system. Existing tools for SDN verification and analysis are insufficiently expressive to capture this composition of network and domain models. Unfortunately, it is exactly this kind of automated reasoning and verification that is necessary to develop robust SDN-enabled applications for real-world systems. In this paper, we present ongoing work on Verificare, a verification platform being built to enable formal verification of SDNs as components of a larger domain-specific system. SLA, safety, and security requirements can selected from a variety of formal libraries and automatically verified using a variety of off-the-shelf tools. This approach not only extends the flexibility of existing SDN verification systems, but can actually provide more fine-grained analysis of possible network states due to extra information supplied by the domain model.

What are polymorphically-typed ambients?
System E: Expansion variables for flexible typing with linear and non-linear types and intersection types
Relating typability and expressiveness in finite-rank intersection type systems
We investigate finite-rank intersection type systems, analyzing the complexity of their type inference problems and their relation to the problem of recognizing semantically equivalent terms. Intersection types allow something of type &tau;<inf>1</inf> &Lambda; &tau;<inf>2</inf> to be used in some places at type &tau;<inf>1</inf> and in other places at type &tau;<inf>2</inf>. A <i>finite-rank</i> intersection type system bounds how deeply the &Lambda; can appear in type expressions. Such type systems enjoy strong normalization, subject reduction, and computable type inference, and they support a pragmatics for implementing parametric polymorphism. As a consequence, they provide a conceptually simple and tractable alternative to the impredicative polymorphism of System F and its extensions, while typing many more programs than the Hindley-Milner type system found in ML and Haskell.While type inference is computable at every rank, we show that its complexity grows exponentially as rank increases. Let <b>K</b>(0, <i>n</i>) = <i>n</i> and <b>K</b>(<i>t</i> + 1, <i>n</i>) = 2<sup><b>K</b>(<i>t,n</i>)</sup>; we prove that recognizing the pure &lambda;-terms of size <i>n</i> that are typable at rank <i>k</i> is complete for <sc>DTIME</sc>[<b>K</b>(<i>k</i>&minus;1, <i>n</i>)]. We then consider the problem of deciding whether two &lambda;-terms typable at rank <i>k</i> have the same normal form, generalizing a well-known result of Statman from simple types to finite-rank intersection types. We show that the equivalence problem is <sc>DTIME</sc>[<b>K</b>(<b>K</b>(<i>k</i> &minus; 1, <i>n</i>), 2)]-complete. This relationship between the complexity of typability and expressiveness is identical in wellknown decidable type systems such as simple types and Hindley-Milner types, but seems to fail for System F and its generalizations. The correspondence gives rise to a conjecture that if &Tau; is a predicative type system where typability has complexity <i>t</i>(<i>n</i>) and expressiveness has complexity <i>e</i>(<i>n</i>), then <i>t</i>(<i>n</i>) = &Omega;(log* <i>e</i>(<i>n</i>)).

Computational consequences and partial solutions of a generalized unification problem
A generalization of first-order unification, called semiunification, is studied with two goals in mind: (1) type-checking functional programs relative to an improved polymorphic type discipline; and (2) deciding the typability of terms in a restricted form of the polymorphic lambda -calculus.<<ETX>>

Definability by programs in first-order structures
DONE