The Case Against Specialized Graph Analytics Engines.
Graph analytic processing has started to become a nearly ubiquitous component in the enterprise data analytics ecosystem. In response to this growing need, various specialized graph processing engines have been created in recent years. Sadly, the use of relational database management systems (RDBMSs) for graph processing is largely ignored in most enterprise settings. This oversight is surprising since in most enterprise settings, RDBMSs are already present and used for a variety of other analytic tasks. This situation then begs the question of whether the use of RDBMS for graph processing is fundamentally lacking in some respect compared to the specialized graph processing engines. In this paper, we aim to address this question both from the programmer productivity perspective and from the performance perspective. We present Grail { a syntactic layer for querying graph in a vertex-centric way in an RDBMS, which can be compiled to translate graph queries to SQL. In a single node setting, we also compare Grail to GraphLab and Giraph, and examine the performance implications of using Grail, showing that the RDBMS engine is competitive to these specialized engines. Given that RDBMSs are ubiquitous in enterprise settings, and have a robust and mature technology that has been hardened over decades, and are part of existing administrative methods in place, we argue that it is time to reconsider if specialized graph engines have a role to play in most enterprises.

Role of live-coding in learning introductory programming
Live-coding is an approach to teaching programming by writing actual code during class as part of the lectures. In a live-coding session, the instructor thinks aloud while writing code and the students are able to understand the process of programming by observing the thought processes of the instructor. In our study, we conducted a live-coding session to two groups of students as a part of a teaching intervention that was originally designed for studying the effects of using the native language for learning programming. We analyzed the student feedback data that was collected and found that many students have mentioned about the usefulness of live-coding for learning programming. We conducted a grounded theory analysis of the student feedback data to understand the value of live-coding for learning introductory programming. We found that live-coding (1) makes the process of programming easy to understand for novice programmers, (2) helps students learn the process of debugging, and (3) exposes students to good programming practices. We also found that students prefer to code along with the instructor during a live-coding session rather than being mere observers.

Does native language play a role in learning a programming language?
Computer Science (CS) is taught in India, using English as the medium of instruction, to students whose native language is not English. This places a high cognitive load on students who learn programming for the first time and who are not very proficient in English. The problems these students face become even harder since learning to program can be an incredibly difficult task. Our study aims to find out if a student's native language has any effect on the student's ability to learn programming. We taught linked list, a basic concept in CS, to two groups of undergraduate students for a week in Tamil Nadu, India. We used English to teach one group of students and English and Tamil (the native language in Tamil Nadu) to teach the other group. Our intervention consisted of three lectures and one live-coding session. We collected quantitative and qualitative data using technical tests and open-ended feedback respectively. We found that although teaching programming using both English and Tamil is no different when compared to using only English with respect to student learning, students have expressed positive opinions about teaching and learning CS using two languages.

Live coding: A review of the literature
One of the goals of computing education research is to document the potential strengths and weaknesses of contemporary teaching methods in computing. Live coding has recently gained attention as one of the best practices for teaching programming. To offer a more comprehensive understanding of the existing body of research about live coding, we reviewed papers in computing education research that investigated the value of live coding in an educational setting. We categorized each paper based on (1) how it defines live coding, (2) whether its version of live coding could be considered active learning, (3) the type of study conducted, (4) types of data collected and the data analysis methods used, (5) evidence provided for the effectiveness of live coding, (6) reported benefits and drawbacks of live coding, and (7) reported theoretical frameworks used to explain the basis, effects or goals of live coding. We found that although live coding has been recommended as one of the best practices for teaching programming, there is a lack of empirical evidence to support claims about the effectiveness of live coding on student learning. Finally, we discuss the implications of our findings and suggest future research directions that could develop a more holistic understanding of this pedagogical technique.

Live-coding vs static code examples: which is better with respect to student learning and cognitive load?
Teaching programming using static code examples is the process of displaying pre-written code examples and explaining the purpose of the code. Live-coding is the process of writing code in-class in front of the students and thinking aloud while doing so. Static coding has more structure (similar to PowerPoint presentations) but lacks the authenticity and dynamic nature of writing code lively in front of an audience since the focus is more on the end product (i.e., program) rather than the process in which the program came to life. On the other hand, live-coding engages the students as the process is dynamic and makes the instructor's thought processes explicit to the students, but it lacks the structure and predictability of static code examples. We conducted an experiment in which we taught programming and data structures in C++ to two groups of undergraduate students. We used live-coding to teach one group (experimental) and static code examples to teach the other group (control). We conducted a pre-test and a post-test to measure students' understanding of programming before and after our intervention respectively. We collected a validated survey to measure the cognitive load experienced by the students in both the groups. Our experiments failed to show a difference between live-coding and static code examples with respect to student learning, but we found that live-coding reduced the extraneous cognitive load on students when compared to static code examples.

Is more active always better for teaching introductory programming?
Introduction to programming is usually taught using a wide range of instructional techniques. Some common techniques among them are mini-lectures, live-coding and in-class coding. Each of these three techniques require varying level of student activity. In this study, we taught programming to a group of students using these three techniques. We collected data in the form of a survey to understand the students' perceptions on these three instructional techniques. The results suggest that students like techniques that require a moderate level of student activity (e.g., live-coding) more when compared to techniques that require a great deal of student activity (e.g., in-class coding). We believe that our work has the potential to help instructors design their instructional techniques using a student-centric approach.

What Do Students Feel about Learning Programming Using Both English and Their Native Language?
Programming is taught in India using English as the medium of instruction to students whose native language is not English. This places a high cognitive load on students who learn programming for the first time and who are not very proficient in English. Our study aims at finding out what the students feel if their native language is used along with English for teaching programming. As a part of our study, we taught linked list, a basic concept in programming, to two groups of undergraduate students for a week in Tamil Nadu, India. We used English to teach one group of students and English and Tamil (the native language in Tamil Nadu) to teach the other group. Our intervention consisted of 3 lectures and 1 live-coding session. We collected qualitative data by means of an open-ended feedback from the students. The analysis of this feedback shows that students have expressed positive sentiments about our bilingual teaching methodologies.

How secure are our computer systems courses?
Introductory computer systems courses teach students how a single program is executed inside a computer, providing them with their first exposure to the logical internals of computing systems. This is one of the first introductory courses where students can learn about security and the need for robust coding. However, currently, these courses are taught with a focus on functionality and efficiency only, ignoring security almost entirely. In this paper, we provide a basic security analysis of computer systems courses from 16 of the top 20 CS undergraduate programs at R1 universities in the US. We collected more than 760 thousand lines of C/C++ code written by 253 students and used by instructors in lectures and for assignments. We found students frequently use unsafe functions such as strcpy, strcat, and system, many of which can lead to serious security vulnerabilities. These unsafe functions are present in course materials such as in lecture slides and textbooks, and even in the code provided by instructors. We also show a high correlation between the unsafe functions used by students with those used by their instructors.

Effect of native language on student learning and classroom interaction in an operating systems course
Understanding an operating systems (OS) code base is a difficult task since it involves understanding a huge amount of low-level C and assembly code. The inherent level of difficulty associated with OS topics is high because of the high element interactivity (i.e., material consists of elements that heavily interact). The mental effort associated with learning a complex subject like OS may be higher for non-native English speakers, when the subject is taught in a natural language (i.e., English) that is not the students' native language. We were interested in finding the effect of an instructional design that combines the students' native language along with English on students' understanding of select topics in OS. We designed an experiment to teach CPU virtualization using xv6 to two groups of undergraduate students in Tamil Nadu, India. We taught the experimental group using English and Tamil (native language of students in Tamil Nadu) and the control group using only English. We conducted a pre-test and a post-test to test students' understanding of the OS topics taught, before and after our intervention respectively. We also collected data on the questions that students asked in lectures during our intervention. We found that teaching OS using native language and English is no different than teaching OS using only English with respect to student learning. We also found that the native language had an impact on the student engagement and classroom interaction by creating more dialogue within the Tamil+English (experimental) classroom when compared to the English-only (control) classroom.

Identifying gaps in the secure programming knowledge and skills of students
Often, security topics are only taught in advanced computer science (CS) courses. However, most US R1 universities do not require students to take these courses to complete an undergraduate CS degree. As a result, students can graduate without learning about computer security and secure programming practices. To gauge students' knowledge and skills of secure programming, we conducted a coding interview with 21 students from two R1 universities in the United States. All the students in our study had at least taken Computer Systems or an equivalent course. We then analyzed the students' approach to safe programming practices, such as avoiding unsafe functions like gets and strcpy, and basic security knowledge, such as writing code that assumes user inputs can be malicious. Our results suggest that students lack the key fundamental skills to write secure programs. For example, students rarely pay attention to details, such as compiler warnings, and often do not read programming language documentation with care. Moreover, some students' understanding of memory layout is cursory, which is crucial for writing secure programs. We also found that some students are struggling with even the basics of C programming, even though it is the main language taught in Computer Systems courses.

Textbook underflow: Insufficient security discussions in textbooks used for computer systems courses
Introductory computer science courses, such as Computer Systems, could be used to provide the first exposure to computer security to students. However, prior work has shown that, in the US's top R1 universities, computer systems courses are not taught with security in mind. It was also shown that students and instructors use unsafe functions in their code, leading to security vulnerabilities. In this paper, we focused on the textbooks used for computer systems courses. We analyzed the discussion of security topics and the use of unsafe functions in the thirteen textbooks used in the top 30 R1 universities in the US for teaching computer systems. We show that many textbooks do not discuss security at all, while some limit their discussion to "undefined behavior'', ignoring that opportunity to discuss potential security issues associated with the undefined behavior. Furthermore, textbooks that talk about security continue using unsafe functions throughout (though not necessarily in vulnerable ways but also without any warning or explanation). We also show that many textbooks do not warn about unsafe functions they use or teach how to use them safely.

Impact of bilingual cs education on student learning and engagement in a data structures course
Learning data structures is hard when taught using a new programming language (e.g., C++), while the students had learned introductory programming in a different language (e.g., C). Learning data structures might even be harder for non-native English speakers, when it is taught in a natural language (e.g., English) that is not the students' native language. We were interested in finding the effect of an instructional design that combines the students' native language (e.g., Tamil) along with English on students' understanding of select topics in a data structures course using C++. We designed an experiment to teach a few data structures (e.g., strings, vectors, maps) in the Standard C++ Library to two groups of undergraduate students in Tamil Nadu, India. We taught the experimental group using English and Tamil (native language of students in Tamil Nadu) and the control group using only English. We conducted a pre-test and a post-test to test students' understanding of programming before and after our intervention. We also conducted an English test to assess their competence in English. We collected data on classroom interaction based on the questions that students asked in lectures during our intervention. We found that teaching data structures using native language and English is no different than teaching data structures using only English. We also found that the native language had an impact on the student engagement and classroom interaction by creating more discussion within the Tamil+English (experimental) classroom when compared to the English-only (control) classroom.

Investigating the impact of using a live programming environment in a CS1 course
Novice programmers often struggle with code understanding and debugging. Live Programming environments visualize the runtime values of a program each time it is modified to provide immediate feedback, which help with tracing the program execution. This paper presents the use of a Live Programming tool in a CS1 course to better understand the impact of Live Programming on novices' learning metrics and their perceptions of the tool. We conducted a within-subjects study at a large public university in a CS1 course in Python (N=237) where students completed tasks in a lab setting, in some cases with a Live Programming environment, and in some cases without. Through post-lab surveys and open-ended feedback, we measured how well students understood the material and how students perceived the programming environment. To understand the impact of Live Programming, we compared the collected data for students who used Live Programming with the data for students who did not. We found that while learning outcomes were the same regardless of whether Live Programming was used or not, students who used the Live Programming tool completed some code tracing tasks faster. Furthermore, students liked the Live Programming environment more, and rated it as more helpful for their learning.

Determining data locality in a distributed system using aggregation of locality summaries
An Analysis of Stress and Sense of Belonging Among Native and Non-native English Speakers Learning Computer Science
Previous studies have shown that non-native English speakers (NNES) have lower confidence levels at the beginning of the term and higher academic expectations for themselves throughout the term. Additionally, although non-native English speakers study for longer hours compared to native English speakers (NES), there were not any differences in their grades. To better understand the experiences of NNES learning Computer Science in a U.S university, we examined possible factors that may contribute to differences in stress and sense of belonging between NES and NNES. From our investigation using weekly surveys, we did not find any significant difference in the stress level reported by NES and NNES. However, we found differences in the factors that contribute to the stress level of NES and NNES. Factors such as 'personal life' and 'requirements for other classes' were major factors that contributed towards the stress level of NES, whereas 'embarrassment asking for help' and 'self doubt' were more common among NNES. As for sense of belonging, we found no significant difference between NES and NNES. Additionally, we found that the number of classmates that NES feel comfortable reaching out to is not a factor affecting their sense of belonging in an introductory computer science class. \endabstract

Experiences of Non-Native English Speakers Learning Computer Science in a US University
Prior work has shown that the adjustment challenges faced by international students in English-speaking universities are primarily attributable to English language proficiency and culture. Although studies in computing education have documented the barriers that non-native English speakers face while learning CS using online programming platforms, little research has been done on their experiences in CS courses within a university setting. In this study, we seek to understand the experiences of non-native English speakers learning CS at a English-speaking university in the United States. Through weekly surveys and course grades from four CS courses, we investigate the differences between non-native and native English speakers with respect to the time spent studying outside of class, confidence levels at the start of a course, types of learning resources used, and expected and actual overall grades. We found that although non-native speakers require a higher minimum grade to be satisfied and often spend a longer time on average studying outside of class compared to native speakers, there was no difference in the actual grade received between the two groups. While there was no significant difference in the type of resources used (online vs in-person), there was a significant difference in the confidence level between native and non-native English speakers.

How to teach" modern C++" to someone who already knows programming?
The C++ programming language has undergone major changes since the introduction of C++11. 'Modern C++,' defined here as C++11 and beyond, can be viewed as a new language compared to C++98 (the version of C++ introduced in 1998). Many new features have been added to modern C++, including lambda expressions and automatic type deduction. The standard library has also been dramatically updated with constructs such as std::unordered_set and smart pointers. The traditional way of teaching C++ by first teaching C's low-level features, such as raw pointers and char * strings, is potentially ineffective when teaching modern C++. Based on this hypothesis, we updated the way in which we teach C++ at UW-Madison by teaching the most important high-level features (containers, iterators, and algorithms) first, and introducing the low-level features (raw pointers, dynamic memory management, etc.) only when they are necessary. In this paper, we present our experiences teaching modern C++ with this top-down approach. We find that with our new approach, students' perceptions about learning C++ are largely positive.

The Impact of a Remote Live-Coding Pedagogy on Student Programming Processes, Grades, and Lecture Questions Asked
Live coding---a pedagogical technique in which an instructor plans, writes, and executes code in front of a class---is generally considered a best practice when teaching programming. However, only a few studies have evaluated the effect of live coding on student learning in a controlled experiment and most of the literature relating to live coding identifies students' perceived benefits of live-coding examples. In order to empirically evaluate the impact of live coding, we designed a controlled experiment in a CS1 course taught in Python at a large public university. In the two remote lecture sections for the course, one was taught using live-coding examples and the other was taught using static-code examples. Throughout the term, we collected code snapshots from students' programming assignments, students' grades, and the questions that they asked during the remote lectures. We then applied a set of process-oriented programming metrics to students' programming data to compare students' adherence to effective programming processes in the two learning groups and categorized each question asked in lectures following an open-coding approach. Our results revealed a general lack of difference between the two groups across programming processes, grades, and lecture questions asked. However, our experiment uncovered minimal effects in favor of the live-coding group indicating improved programming processes but lower performance on assignments and grades. Our results suggest an overall insignificant impact of the style of presenting code examples, though we reflect on the threats to validity in our study that should be addressed in future work.

The effects of spanish-english bilingual instruction in a cs0 course for high school students
Prior studies in multilingual computing education have shown that many non-native English speakers (NNES) in India struggle with introductory programming courses as they learn both a programming language (e.g., Java) and a natural language (e.g., English) concurrently. Although multiple studies have been conducted with NNES in India whose first language is Hindi or Tamil, we do not yet know the influence a students' native language may have among Spanish speaking students in the United States. This replication study investigates the effects of an instructional design integrating the students' native language along with English on high school students' learning and engagement in a two week CS0 course using the block-based programming language, Scratch. We designed an experiment to teach introductory computing topics (e.g., algorithms, variables, loops, conditionals) to two groups of students from a rural area spanning multiple institutions in the US. The experimental group was taught using English and Spanish (students' native language) and the control section was taught using only English. A pre-test and post-test was conducted to test students' programming knowledge before and after the course. We also recorded all the questions students asked during the course to measure student engagement. We found that teaching Scratch programming using Spanish and English is no different than teaching Scratch programming using only English to high school students whose native language is Spanish. We also found that the students in the experimental group asked more questions when compared to the control group.

Understanding and Measuring Incremental Development in CS1
Incremental development is the process of writing a small snippet of code and testing it before moving on. For students in introductory programming courses, the value of incremental development is especially higher as they may suffer from more syntax errors, lack the proficiency to address complicated bugs, and may be more prone to frustration when struggling to correct code. However, to evaluate the effectiveness of interventions that aim to teach programming processes such as incremental development, we need to develop measures to assess such processes. In this paper, we present a way to measure incremental development. By qualitatively analyzing 15 student coding interviews, we identified common behaviors in the programming process that relate to incremental development. We then leveraged a dataset of over 1000 development sessions -- about 52,000 code snapshots at compilation time -- to automatically detect the common behaviors identified in our qualitative analysis. Finally, we crafted a formal metric, called the "Measure of Incremental Development'' (MID), to quantify how effectively a student used incremental development during a programming session. The MID detects common non-incremental development patterns such as excessive debugging after large additions of code to automatically assess a sequence of snapshots. The MID aligns with human evaluations of incrementality with over 80% accuracy. Our metric enables new research directions and interventions focused on improving students' development practices.

DONE